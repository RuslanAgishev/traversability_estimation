#!/usr/bin/env python

import matplotlib.pyplot as plt
import torch
from torchdiffeq import odeint, odeint_adjoint
import torch.optim as optim
import numpy as np
import os
from traversability_estimation.models import TerrainPredictor, LinearPredictor
from traversability_estimation.models import RigidBodySoftTerrain

CREATE_MOVIE = 0  # 1-True, 0-False
VISU = 1  # 0-no, 1-matplotlib, 2-mayavi

OUTPUT_PATH = '/home/ruslan/workspaces/traversability_ws/src/traversability_estimation/data/output'

torch.set_default_dtype(torch.float64)

MAX_ROBOT_WIDTH = 2.0
MAX_ROBOT_LENGTH = 4.0
GRID_RES = 0.1

if VISU == 2:
    from mayavi import mlab

def main():
    height_gt = np.array([ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                           [0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5],
                           [0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5],
                           [0.5, 0.5, 0.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.5],
                           [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0],
                           [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                           [0.5, 0.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.5, 0.5],
                           [0.5, 0.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.5, 0.5],
                           [0.5, 0.5, 0.0, 0.5, 0.7, 0.5, 0.5, 0.0, 0.5, 0.7],
                           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ])

    system_true = RigidBodySoftTerrain(height=height_gt, damping=300.0, elasticity=5000.0, mass=20.0)

    total_time = 4.0
    number_of_samples = 100
    t0, state = system_true.get_initial_state()
    tt = torch.linspace(float(t0), total_time, number_of_samples)
    x_true = odeint(system_true.forward, state, tt, atol=1e-3, rtol=1e-3)

    # height_init = np.zeros_like(height_gt)
    height_init = 0.5 * height_gt + 0.6

    # terrain_predictor = TerrainPredictor(encChannels=(1, 2, 4), decChannels=(4, 2))
    terrain_predictor = LinearPredictor()

    system = RigidBodySoftTerrain(height=height_init, terrain_predictor=terrain_predictor,
                                  damping=300.0, elasticity=5000.0, mass=20.0)

    optimizer = optim.Adam(system.terrain_predictor.parameters(), lr=0.02)

    x_true_x, x_true_R, x_true_v, x_true_omega = x_true[0].detach(), x_true[1].detach(), x_true[2].detach(), x_true[3].detach()
    k, time, sample_length = 0, 0, 10
    for i in range(100):
        optimizer.zero_grad()

        loss = torch.zeros(1)
        for time in range(int(number_of_samples / sample_length)):
            s = (x_true[0][time * sample_length].detach(), x_true[1][time * sample_length].detach(), x_true[2][time * sample_length].detach(), x_true[3][time * sample_length].detach(), x_true[4][time * sample_length].detach())
            x = odeint(system.forward, s, tt[time * sample_length:(time + 1) * sample_length], atol=1e-3, rtol=1e-3)
            loss += ((x[0] - x_true_x[time * sample_length:(time + 1) * sample_length]) ** 2).sum()

        loss.backward()
        optimizer.step()

        print('loss=%.3f' % loss.item())
        print('height map mean:', system.height.mean().item())
        # print('mean elastisity: %.3f' % system.elasticity.mean().item())
        # print('mean damping: %.3f' % system.damping.mean().item())

        if i % 10 == 0:
            x = odeint(system.forward, state, tt, atol=1e-3, rtol=1e-3)
            pos_x, pos_R, vel_x, vel_omega, aux = x
            x_grid, y_grid = np.mgrid[0:system.height.shape[0], 0:system.height.shape[1]]
            h = system.height.detach().numpy()
            # h = system.height[0, :].detach().numpy().squeeze()
            points = system.d.detach().numpy()
            if VISU == 1:
                plt.clf()
                points = pos_R @ system.d + pos_x
                cols = ['c', 'k', 'c', 'y']
                for t in range(points.shape[0]):
                    plt.clf()
                    plt.plot(pos_x[:, 0].detach().numpy(), pos_x[:, 2].detach().numpy(), 'o--', color='r', linewidth=2.0)
                    plt.plot(x_true_x[:, 0].numpy(), x_true_x[:, 2].detach().numpy(), 'o--', color='b', linewidth=2.0)
                    # plt.bar(np.linspace(0, h.shape[0] - 1, h.shape[0]), h)
                    plt.axis('equal')
                    plt.grid()
                    plt.title('loss = ' + str(loss.detach().numpy()))
                    for cog in range(2):
                        plt.plot([points[t, 0, cog].detach().numpy(), points[t, 0, (cog + 1) % 4].detach().numpy()],
                                 [points[t, 2, cog].detach().numpy(), points[t, 2, (cog + 1) % 4].detach().numpy()], '.-',
                                 color=cols[cog], linewidth=5.0)
                    plt.pause(0.01)
                    if CREATE_MOVIE:
                        plt.savefig(OUTPUT_PATH + '{:04d}_frame'.format(k * points.shape[0] + t) + '.png')
            elif VISU == 2:
                for t in range(pos_x.shape[0]):
                    _, _, _, _, f = system.forward(tt[t], (pos_x[t], pos_R[t], vel_x[t], vel_omega[t], aux[t]))
                    mlab.clf()
                    #mlab.barchart(np.tile(h, (3, 1)).transpose(), opacity=0.1)
                    #robot.plot_robot_Rt([], pos_R[t].detach().numpy(), pos_x[t].detach().numpy())
                    mlab.surf(x_grid, y_grid, h, opacity=0.5, representation='wireframe', line_width=5.0)
                    mlab.surf(x_grid, y_grid, h, color=(0.5, 0.5, 1.0), opacity=0.5, representation='surface')
                    cog = pos_x[t].detach().numpy()
                    rot = pos_R[t].detach().numpy()
                    d = rot @ points
                    mlab.plot3d(x_true_x[:, 0].numpy(), x_true_x[:, 1].detach().numpy(), x_true_x[:, 2].detach().numpy(), color=(0, 0, 1), line_width=2.0)
                    mlab.plot3d(pos_x[:, 0].detach().numpy(), pos_x[:, 1].detach().numpy(), pos_x[:, 2].detach().numpy(), color=(1, 0, 0), line_width=2.0)
                    mlab.points3d(cog[0] + d[0, :], cog[1] + d[1, :], cog[2] + d[2, :], scale_factor=0.25)
                    mlab.quiver3d(cog[0] + d[0, :], cog[1] + d[1, :], cog[2] + d[2, :], f[0].detach().numpy(), f[1].detach().numpy(), f[2].detach().numpy(), scale_factor=0.002)

                    mlab.view(azimuth=(150 - (k * pos_x.shape[0] + t)), elevation=80, distance=12.0)
                    mlab.title('loss = ' + str(loss.detach().numpy()))

                    if VISU == 2:
                        mlab.savefig(filename=OUTPUT_PATH + '{:04d}_frame'.format(k * pos_x.shape[0] + t) + '.png', magnification=1.0)

            k = k + 1

    if CREATE_MOVIE:
        fr = number_of_samples / total_time
        os.system('rm ' + OUTPUT_PATH + 'output.mp4')
        os.system('ffmpeg -r ' + str(fr) + ' -i ' + OUTPUT_PATH + '%04d_frame.png -c:v libx264 -crf 5 -pix_fmt yuv420p ' + OUTPUT_PATH + 'output.mp4')
        # -vf "crop=1700:1000:100:200"


if __name__ == '__main__':
    main()
