#!/usr/bin/env python

from __future__ import absolute_import, division, print_function
import rospy
from sensor_msgs.msg import PointCloud2
import torch
from ros_numpy import msgify, numpify
from message_filters import ApproximateTimeSynchronizer, Subscriber
from numpy.lib.recfunctions import structured_to_unstructured, unstructured_to_structured
import scipy.spatial
import numpy as np
import matplotlib.pyplot as plt


def to_cloud_msg(cloud, time_stamp, frame, names=None):
    if not names:
        names = ['x', 'y', 'z']
        cloud = cloud[:, :3]
    if cloud.dtype.names is None:
        cloud = unstructured_to_structured(cloud, names=names)
    pc_msg = msgify(PointCloud2, cloud)
    pc_msg.header.stamp = time_stamp
    pc_msg.header.frame_id = frame
    return pc_msg


class TravFusion:
    def __init__(self):
        if torch.cuda.is_available():
            self.device = torch.device("cuda:0")
            torch.cuda.set_device(self.device)
        else:
            self.device = torch.device("cpu")

        self.geometric_topic = rospy.get_param('~geometric_trav', 'geometric_traversability_raw')
        self.semantic_topic = rospy.get_param('~semantic_trav', 'cloud_segmentation/points')
        rospy.loginfo("Subscribing to %s and %s", self.geometric_topic, self.semantic_topic)
        self.dist_th = rospy.get_param('~dist_th', 0.25)
        self.max_time_diff = rospy.get_param('~max_time_diff', 0.2)
        self.geometric_weight = rospy.get_param('~geometric_weight', 0.5)
        self.semantic_weight = rospy.get_param('~semantic_weight', 0.5)
        self.flat_cost_th = rospy.get_param('~flat_cost_th', 0.5)
        self.obstacle_cost_th = rospy.get_param('~obstacle_cost_th', 1.0)

        self.geom_msg = None
        self.sem_msg = None
        self.data_fields = ['x', 'y', 'z', 'cost']

        self.fused_pc_pub = rospy.Publisher('~points', PointCloud2, queue_size=1)

        # self.geom_sub = rospy.Subscriber(self.geometric_topic, PointCloud2, queue_size=1, callback=self.update_geom_trav)
        # self.seman_sub = rospy.Subscriber(self.semantic_topic, PointCloud2, queue_size=1, callback=self.update_seman_trav)

        self.geom_sub = Subscriber(self.geometric_topic, PointCloud2)
        self.seman_sub = Subscriber(self.semantic_topic, PointCloud2)
        self.time_synch = ApproximateTimeSynchronizer([self.geom_sub, self.seman_sub], queue_size=1,
                                                      slop=self.max_time_diff)
        self.time_synch.registerCallback(self.update_trav)

        self.rate = rospy.Rate(rospy.get_param('~rate', 10))
        self.spin()

    def update_trav(self, geom_msg, sem_msg):
        self.geom_msg = geom_msg
        self.sem_msg = sem_msg

    def update_geom_trav(self, msg):
        self.geom_msg = msg

    def update_seman_trav(self, msg):
        self.sem_msg = msg

    def msg_to_cloud(self, msg):
        cloud = numpify(msg, PointCloud2)
        cloud = cloud[self.data_fields]
        cloud = structured_to_unstructured(cloud)
        return cloud

    def fusion(self, geom_cloud, sem_cloud, distance_filter=False):
        # choose closest points from semantic cloud to geometric cloud
        tree = scipy.spatial.cKDTree(geom_cloud)
        dists, idxs = tree.query(sem_cloud, k=1)
        geom_cloud = geom_cloud[idxs]

        if distance_filter:
            dists_mask = dists <= self.dist_th
            geom_cloud = geom_cloud[dists_mask]
            sem_cloud = sem_cloud[dists_mask]

        assert geom_cloud.shape[0] == sem_cloud.shape[0]
        fused_cloud = sem_cloud.copy()

        geom_cost = geom_cloud[:, 3]
        sem_cost = sem_cloud[:, 3]

        fused_cost = geom_cost.copy()
        # fused_cost[geom_cost < self.flat_cost_th] = 0.0
        # fused_cost[geom_cost > self.obstacle_cost_th] = geom_cost[geom_cost > self.obstacle_cost_th] + \
        #                                                 sem_cost[geom_cost > self.obstacle_cost_th]
        fused_cost[geom_cost > self.flat_cost_th] = self.flat_cost_th + sem_cost[geom_cost > self.flat_cost_th]
        fused_cost[geom_cost > self.obstacle_cost_th] = geom_cost[geom_cost > self.obstacle_cost_th]

        # plt.cla()
        # plt.plot(geom_cost[::10], label='Geom cost')
        # plt.plot(sem_cost[::10], label='Semantic cost')
        # plt.plot(fused_cost[::10], label='Fused cost')
        # plt.legend()
        # plt.grid()
        # plt.draw()
        # plt.pause(0.1)

        fused_cloud[:, 3] = fused_cost

        del sem_cloud
        del geom_cloud
        del geom_cost
        del sem_cost

        return fused_cloud

    def spin(self):
        # plt.figure(figsize=(20, 10))
        while not rospy.is_shutdown():
            if not self.geom_msg:
                rospy.logwarn('Geometric traversability is not received')
                fused_cloud = self.msg_to_cloud(self.sem_msg) if self.sem_msg else None
            elif not self.sem_msg:
                rospy.logwarn('Semantic traversability is not received')
                fused_cloud = self.msg_to_cloud(self.geom_msg) if self.geom_msg else None
            else:
                assert isinstance(self.geom_msg, PointCloud2)
                assert isinstance(self.sem_msg, PointCloud2)
                assert self.geom_msg.header.frame_id == self.sem_msg.header.frame_id

                geom_cloud = self.msg_to_cloud(self.geom_msg)
                sem_cloud = self.msg_to_cloud(self.sem_msg)

                assert geom_cloud.ndim == sem_cloud.ndim == 2
                assert geom_cloud.shape[1] == sem_cloud.shape[1] == 4

                time_diff = abs(self.sem_msg.header.stamp.to_sec() - self.geom_msg.header.stamp.to_sec())
                if time_diff > self.max_time_diff:
                    rospy.logwarn_once('Geometric and semantic clouds have big time stamp difference: %s.\n'
                                       'Using geometric segmentation as fusion result',
                                       time_diff)
                    fused_cloud = geom_cloud

                else:
                    rospy.logdebug('Running traversability fusion: geometric + semantic')
                    fused_cloud = self.fusion(geom_cloud, sem_cloud)

            if fused_cloud is not None:
                frame = self.sem_msg.header.frame_id if self.sem_msg else self.geom_msg.header.frame_id
                now = rospy.Time.now()
                fused_trav_msg = to_cloud_msg(fused_cloud, time_stamp=now, frame=frame, names=self.data_fields)
                self.fused_pc_pub.publish(fused_trav_msg)

            self.rate.sleep()


if __name__ == '__main__':
    rospy.init_node('traversability_fusion', log_level=rospy.INFO)
    proc = TravFusion()
    rospy.spin()
