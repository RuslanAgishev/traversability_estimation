#!/usr/bin/env python

from __future__ import absolute_import, division, print_function
import rospy
from sensor_msgs.msg import PointCloud2
import torch
from ros_numpy import msgify, numpify
from numpy.lib.recfunctions import structured_to_unstructured, unstructured_to_structured
from message_filters import ApproximateTimeSynchronizer, Subscriber


def to_cloud_msg(cloud, time_stamp, frame, names=None):
    if not names:
        names = ['x', 'y', 'z']
        cloud = cloud[:, :3]
    if cloud.dtype.names is None:
        cloud = unstructured_to_structured(cloud, names=names)
    pc_msg = msgify(PointCloud2, cloud)
    pc_msg.header.stamp = time_stamp
    pc_msg.header.frame_id = frame
    return pc_msg


class PointsProcessor:
    def __init__(self):
        if torch.cuda.is_available():
            self.device = torch.device("cuda:0")
            torch.cuda.set_device(self.device)
        else:
            self.device = torch.device("cpu")

        self.geometric_topic = rospy.get_param('~geometric_trav', 'geometric_traversability_raw')
        self.semantic_topic = rospy.get_param('~semantic_trav', 'cloud_segmentation/points')
        rospy.loginfo("Subscribing to %s and %s", self.geometric_topic, self.semantic_topic)
        self.max_pts_difference = rospy.get_param('~max_pts_diff', 10)
        self.geometric_weight = rospy.get_param('~geometric_weight', 0.5)
        self.semantic_weight = rospy.get_param('~semantic_weight', 0.5)
        self.slop = rospy.get_param('~slop', 0.1)

        self.data_fields = ['x', 'y', 'z', 'cost']

        geometric_sub = Subscriber(self.geometric_topic, PointCloud2)
        semantic_sub = Subscriber(self.semantic_topic, PointCloud2)
        self.time_synch = ApproximateTimeSynchronizer([geometric_sub, semantic_sub], queue_size=1, slop=self.slop)
        self.time_synch.registerCallback(self.pc_callback)

        self.fused_pc_pub = rospy.Publisher('~points', PointCloud2, queue_size=1)

    def pc_callback(self, geom_msg, sem_msg):
        assert isinstance(geom_msg, PointCloud2)
        assert isinstance(sem_msg, PointCloud2)
        assert geom_msg.header.frame_id == sem_msg.header.frame_id
        frame = sem_msg.header.frame_id
        now = rospy.Time.now()

        geom_cloud = numpify(geom_msg, PointCloud2)
        sem_cloud = numpify(sem_msg, PointCloud2)

        geom_cloud = geom_cloud[self.data_fields]
        sem_cloud = sem_cloud[self.data_fields]
        assert sem_cloud.dtype.names == geom_cloud.dtype.names

        geom_cloud = structured_to_unstructured(geom_cloud)
        sem_cloud = structured_to_unstructured(sem_cloud)

        assert geom_cloud.ndim == sem_cloud.ndim == 2
        assert geom_cloud.shape[1] == sem_cloud.shape[1] == 4

        if abs(geom_cloud.shape[0] - sem_cloud.shape[0]) > 10:
            rospy.logwarn('Geometric and semantic clouds have different number of points: %s, %s.'
                          'Using geometric segmentation as fusion result',
                          geom_cloud.shape[0], sem_cloud.shape[0])
            fused_cloud = geom_cloud
        else:
            n_pts = min(geom_cloud.shape[0], sem_cloud.shape[0])
            geom_cloud = geom_cloud[:n_pts]
            sem_cloud = sem_cloud[:n_pts]
            assert geom_cloud.shape[0] == sem_cloud.shape[0]
            fused_cloud = sem_cloud
            fused_cloud[:, 3] = self.geometric_weight * geom_cloud[:, 3] + self.semantic_weight * sem_cloud[:, 3]

        map_msg = to_cloud_msg(fused_cloud, time_stamp=now, frame=frame, names=self.data_fields)
        self.fused_pc_pub.publish(map_msg)


if __name__ == '__main__':
    rospy.init_node('traversability_fusion', log_level=rospy.INFO)
    proc = PointsProcessor()
    rospy.spin()
