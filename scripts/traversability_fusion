#!/usr/bin/env python

from __future__ import absolute_import, division, print_function

import numpy as np

import rospy
from sensor_msgs.msg import PointCloud2
import torch
from ros_numpy import msgify, numpify
from numpy.lib.recfunctions import structured_to_unstructured, unstructured_to_structured
# from message_filters import ApproximateTimeSynchronizer, Subscriber


def to_cloud_msg(cloud, time_stamp, frame, names=None):
    if not names:
        names = ['x', 'y', 'z']
        cloud = cloud[:, :3]
    if cloud.dtype.names is None:
        cloud = unstructured_to_structured(cloud, names=names)
    pc_msg = msgify(PointCloud2, cloud)
    pc_msg.header.stamp = time_stamp
    pc_msg.header.frame_id = frame
    return pc_msg


class PointsProcessor:
    def __init__(self):
        if torch.cuda.is_available():
            self.device = torch.device("cuda:0")
            torch.cuda.set_device(self.device)
        else:
            self.device = torch.device("cpu")

        self.geometric_topic = rospy.get_param('~geometric_trav', 'geometric_traversability_raw')
        self.semantic_topic = rospy.get_param('~semantic_trav', 'cloud_segmentation/points')
        rospy.loginfo("Subscribing to %s and %s", self.geometric_topic, self.semantic_topic)
        self.max_pts_difference = rospy.get_param('~max_pts_diff', 100)
        self.max_time_diff = rospy.get_param('~max_time_diff', 0.2)
        self.geometric_weight = rospy.get_param('~geometric_weight', 0.5)
        self.semantic_weight = rospy.get_param('~semantic_weight', 0.5)

        self.geom_msg = None
        self.sem_msg = None
        self.data_fields = ['x', 'y', 'z', 'cost']

        self.fused_pc_pub = rospy.Publisher('~points', PointCloud2, queue_size=1)

        geom_sub = rospy.Subscriber(self.geometric_topic, PointCloud2, queue_size=1, callback=self.update_geom_trav)
        seman_sub = rospy.Subscriber(self.semantic_topic, PointCloud2, queue_size=1, callback=self.update_seman_trav)
        self.rate = rospy.Rate(rospy.get_param('~rate', 10))
        self.spin()

    def update_geom_trav(self, msg):
        self.geom_msg = msg

    def update_seman_trav(self, msg):
        self.sem_msg = msg

    def msg_to_cloud(self, msg):
        cloud = numpify(msg, PointCloud2)
        cloud = cloud[self.data_fields]
        cloud = structured_to_unstructured(cloud)
        return cloud

    def spin(self):
        while not rospy.is_shutdown():
            if not self.geom_msg:
                rospy.logwarn('Geometric traversability is not received')
                if self.sem_msg:
                    fused_cloud = self.msg_to_cloud(self.sem_msg)
                else:
                    continue
            elif not self.sem_msg:
                rospy.logwarn('Semantic traversability is not received')
                if self.geom_msg:
                    fused_cloud = self.msg_to_cloud(self.geom_msg)
                else:
                    continue
            else:
                assert isinstance(self.geom_msg, PointCloud2)
                assert isinstance(self.sem_msg, PointCloud2)
                assert self.geom_msg.header.frame_id == self.sem_msg.header.frame_id

                geom_cloud = self.msg_to_cloud(self.geom_msg)
                sem_cloud = self.msg_to_cloud(self.sem_msg)

                assert geom_cloud.ndim == sem_cloud.ndim == 2
                assert geom_cloud.shape[1] == sem_cloud.shape[1] == 4

                pts_diff = abs(geom_cloud.shape[0] - sem_cloud.shape[0])
                time_diff = abs(self.sem_msg.header.stamp.to_sec() - self.geom_msg.header.stamp.to_sec())

                if pts_diff > self.max_pts_difference:
                    rospy.logwarn('Geometric and semantic clouds have different number of points: %s, %s.\n'
                                  'Using geometric segmentation as fusion result',
                                  geom_cloud.shape[0], sem_cloud.shape[0])
                    fused_cloud = geom_cloud

                elif time_diff > self.max_time_diff:
                    rospy.logwarn('Geometric and semantic clouds have big time stamp difference: %s.\n'
                                  'Using geometric segmentation as fusion result',
                                  time_diff)
                    fused_cloud = geom_cloud

                else:
                    n_pts = min(geom_cloud.shape[0], sem_cloud.shape[0])
                    geom_cloud = geom_cloud[:n_pts]
                    sem_cloud = sem_cloud[:n_pts]
                    assert geom_cloud.shape[0] == sem_cloud.shape[0]
                    fused_cloud = sem_cloud
                    fused_cloud[:, 3] = self.geometric_weight * geom_cloud[:, 3] + self.semantic_weight * sem_cloud[:, 3]

            frame = self.sem_msg.header.frame_id if self.sem_msg else self.geom_msg.header.frame_id
            now = rospy.Time.now()
            fused_trav_msg = to_cloud_msg(fused_cloud, time_stamp=now, frame=frame, names=self.data_fields)
            self.fused_pc_pub.publish(fused_trav_msg)

            self.rate.sleep()


if __name__ == '__main__':
    rospy.init_node('traversability_fusion', log_level=rospy.INFO)
    proc = PointsProcessor()
    rospy.spin()
