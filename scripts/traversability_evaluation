#!/usr/bin/env python

from __future__ import absolute_import, division, print_function
import rospy
from sensor_msgs.msg import PointCloud2
from stamped_msgs.msg import Float64
import tf2_ros
import torch
import numpy as np
from ros_numpy import msgify, numpify
from numpy.lib.recfunctions import structured_to_unstructured, unstructured_to_structured
from scipy.spatial import KDTree


def to_cloud_msg(cloud, time_stamp, frame):
    # publish point cloud
    if cloud.dtype.names is None:
        cloud = unstructured_to_structured(cloud[:, :3], names=['x', 'y', 'z'])
    pc_msg = msgify(PointCloud2, cloud)
    pc_msg.header.stamp = time_stamp
    pc_msg.header.frame_id = frame
    return pc_msg


class TravEval:
    def __init__(self):
        self.robot_frame = rospy.get_param('~robot_frame', 'base_link')
        self.odom_frame = rospy.get_param('~odom_frame', 'odom')
        self.pc_topic = rospy.get_param('~cloud', 'graph_pcd')
        self.robot_radius = rospy.get_param('~robot_radius', 1.0)
        self.pc_frame = None
        self.clouds = []
        if torch.cuda.is_available():
            self.device = torch.device("cuda:0")
            torch.cuda.set_device(self.device)
        else:
            self.device = torch.device("cpu")

        rospy.loginfo("Subscribed to " + self.pc_topic)
        pc_sub = rospy.Subscriber(self.pc_topic, PointCloud2, self.pc_callback)
        self.tf = tf2_ros.Buffer()
        self.tl = tf2_ros.TransformListener(self.tf)

        self.trav_field = rospy.get_param('~trav_field', 'untrav_cost')
        self.traversed_points_history = None
        self.cost = 0.0

        self.traversed_grid_pcd_pub = rospy.Publisher('~traversed_points', PointCloud2, queue_size=1)
        self.cost_pub = rospy.Publisher('~untrav_cost', Float64, queue_size=1)

    def pc_callback(self, pc_msg):
        assert isinstance(pc_msg, PointCloud2)

        cloud = numpify(pc_msg)
        points = structured_to_unstructured(cloud[['x', 'y', 'z']])
        traversability = structured_to_unstructured(cloud[[self.trav_field]])
        rospy.logdebug('Traversability values: %s', np.unique(traversability))

        self.pc_frame = pc_msg.header.frame_id
        if self.pc_frame != self.robot_frame:
            try:
                trans = self.tf.lookup_transform(self.robot_frame, self.pc_frame, rospy.Time())
            except Exception as e:
                rospy.logwarn('No transformation between %s and %s: %s', self.pc_frame, self.robot_frame, e)
                return
            # transform point cloud to robot frame
            pose = numpify(trans.transform)
            points_robot_frame = np.matmul(points, pose[:3, :3].T) + pose[:3, 3:].T
        else:
            points_robot_frame = points

        robot_point = np.array([0, 0, 0])
        graph_tree = KDTree(points_robot_frame)
        nearest_graph_points_ind = graph_tree.query_ball_point(robot_point, r=self.robot_radius)
        nearest_graph_points = points_robot_frame[nearest_graph_points_ind]

        self.cost += traversability[nearest_graph_points_ind].sum()
        rospy.loginfo('Traversability cost for robot poses in planning graph: %s', self.cost)

        t_now = rospy.Time.now()
        nearest_graph_points_msg = to_cloud_msg(nearest_graph_points,
                                                frame=self.robot_frame, time_stamp=t_now)
        self.traversed_grid_pcd_pub.publish(nearest_graph_points_msg)
        cost_msg = Float64()
        cost_msg.header.stamp = t_now
        cost_msg.data = self.cost
        self.cost_pub.publish(cost_msg)


if __name__ == '__main__':
    rospy.init_node('traversability_evaluation', log_level=rospy.INFO)
    proc = TravEval()
    rospy.spin()
