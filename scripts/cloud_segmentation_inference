#!/usr/bin/env python

import os
import cv2
import datasets
from datasets.utils import convert_color
import rospy
from sensor_msgs.msg import Image, PointCloud2
from ros_numpy import msgify, numpify
import numpy as np
from numpy.lib.recfunctions import structured_to_unstructured, unstructured_to_structured
from timeit import default_timer as timer
import torch
import yaml


pkg_path = os.path.realpath(os.path.join(os.path.dirname(__file__), '..'))


def msgify_cloud(cloud, frame, stamp, names):
    cloud = unstructured_to_structured(cloud, names=names)
    msg = msgify(PointCloud2, cloud)
    msg.header.frame_id = frame
    msg.header.stamp = stamp
    return msg


class CloudProcessor:
    def __init__(self, cloud_topic='cloud'):
        self.local_map = None
        self.new_map = None
        self.lidar_frame = None
        self.lidar_channels = rospy.get_param('~lidar_channels', 64)
        self.lidar_beams = rospy.get_param('~lidar_beams', 2048)
        self.lidar_fov_up = rospy.get_param('~lidar_fov_up', 22.5)
        self.lidar_fov_down = rospy.get_param('~lidar_fov_down', -22.5)

        label_map = rospy.get_param('~label_map', None)
        assert label_map is None or isinstance(label_map, (dict, list))
        if isinstance(label_map, dict):
            label_map = dict((int(k), int(v)) for k, v in label_map.items())
            n = max(label_map) + 1
            self.label_map = np.zeros((n,), dtype=np.uint8)
            for k, v in label_map.items():
                self.label_map[k] = v
        elif isinstance(label_map, list):
            self.label_map = np.asarray(label_map)
        else:
            self.label_map = None
        if self.label_map is not None:
            rospy.loginfo('Label map: %s', self.label_map)

        self.input_pc_fields = rospy.get_param('~input_fields', ['x', 'y', 'z', 'i'])
        self.output_pc_filelds = rospy.get_param('~output_fields', ['x', 'y', 'z', 'r', 'g', 'b', 'labels'])
        self.device = rospy.get_param('~device', 'cpu')
        self.model = self.load_model()

        data_cfg = yaml.safe_load(open(os.path.join(pkg_path, "config/rellis.yaml"), 'r'))
        self.color_map = data_cfg['color_map']

        # any point that is farer than this threshold from points in existing pcl is considered as new
        self.max_age = rospy.get_param('~max_age', 10.0)

        self.rate = rospy.get_param('~rate', 1.0)
        self.segm_cloud_pub = rospy.Publisher(rospy.get_param('~cloud_out', 'cloud_out'), PointCloud2, queue_size=1)
        self.resized_cloud_pub = rospy.Publisher('resized_cloud', PointCloud2, queue_size=1)
        self.resized_depth_pub = rospy.Publisher('resized_depth', Image, queue_size=1)

        self.cloud_sub = rospy.Subscriber(cloud_topic, PointCloud2, self.segment_cloud_cb)
        rospy.loginfo('Point cloud processing node is ready.')

    def load_model(self):
        model_weights = rospy.get_param('~weights', "fcn_resnet50_legacy.pth")
        path = os.path.join(pkg_path, "config/weights/", "depth_cloud/%s" % model_weights)
        model = torch.load(path, map_location=self.device)
        model = model.eval()
        rospy.loginfo('Loaded cloud segmentation model: %s', model_weights)
        return model

    def preprocessing(self, cloud):
        # self.scan.set_points(points=cloud[..., 0:3], remissions=cloud[..., 3])
        # # rospy.logdebug('Depth image shape: %s', self.scan.proj_range.shape)
        # cloud = np.concatenate([self.scan.proj_xyz.transpose([2, 0, 1]),  # (3 x H x W)
        #                         self.scan.proj_remission[None],  # (1 x H x W)
        #                         self.scan.proj_range[None]], axis=0)  # (1 x H x W)
        # rospy.logdebug('xyzir input shape: %s', cloud.shape)
        # assert cloud.shape == (5, self.lidar_channels, self.lidar_beams)

        C = cloud.shape[-1]
        if len(cloud.shape) == 3:
            H, W, C = cloud.shape
            self.lidar_channels = H
            self.lidar_beams = W

            # Resize if needed.
            # if False and (self.lidar_channels != cloud.shape[0] or self.lidar_beams != cloud.shape[1]):
            if self.lidar_channels != cloud.shape[0] or self.lidar_beams != cloud.shape[1]:
                resized = []
                for i in range(cloud.shape[2]):
                    c = cv2.resize(cloud[..., i], (self.lidar_channels, self.lidar_beams),
                                   interpolation=cv2.INTER_LINEAR)
                    resized.append(c)
                resized = np.stack(resized, axis=-1)
                cloud = resized
                rospy.loginfo('Point cloud resized to %s', resized.shape)
                # Publish resized point cloud for debugging.
                resized_struct = unstructured_to_structured(resized, names=self.input_pc_fields)
                resized_msg = msgify(PointCloud2, resized_struct)
                self.resized_cloud_pub.publish(resized_msg)

            cloud = cloud.reshape([H * W, C])
        assert cloud.shape == (self.lidar_channels * self.lidar_beams, C)

        # laser parameters
        fov_up = self.lidar_fov_up / 180.0 * np.pi  # field of view up in rad
        fov_down = self.lidar_fov_down / 180.0 * np.pi  # field of view down in rad
        fov = abs(fov_down) + abs(fov_up)  # get field of view total in rad

        # get depth of all points
        depth = np.linalg.norm(cloud, 2, axis=-1)

        # get scan components
        scan_x = cloud[..., 0]
        scan_y = cloud[..., 1]
        scan_z = cloud[..., 2]

        # get angles of all points
        yaw = -np.arctan2(scan_y, scan_x)
        pitch = np.arcsin(scan_z / (depth + 1e-8))

        # get projections in image coords
        proj_x = 0.5 * (yaw / np.pi + 1.0)  # in [0.0, 1.0]
        proj_y = 1.0 - (pitch + abs(fov_down)) / fov  # in [0.0, 1.0]

        # scale to image size using angular resolution
        H, W = self.lidar_channels, self.lidar_beams
        proj_x *= W  # in [0.0, W]
        proj_y *= H  # in [0.0, H]

        # round and clamp for use as index
        proj_x = np.floor(proj_x)
        proj_x = np.minimum(W - 1, proj_x)
        proj_x = np.maximum(0, proj_x).astype(np.int32)  # in [0,W-1]

        proj_y = np.floor(proj_y)
        proj_y = np.minimum(H - 1, proj_y)
        proj_y = np.maximum(0, proj_y).astype(np.int32)  # in [0,H-1]

        # order in decreasing depth
        order = np.argsort(depth)[::-1]
        depth = depth[order]
        points = cloud[order, :3]
        intensity = cloud[order, 3]
        if intensity.max() > 1.0:
            intensity /= 2**16
        proj_y = proj_y[order]
        proj_x = proj_x[order]

        # assing to images
        proj_xyz = np.full((H, W, 3), -1, dtype=np.float32)
        proj_intensity = np.full((H, W), -1, dtype=np.float32)
        proj_depth = np.full((H, W), -1, dtype=np.float32)

        proj_xyz[proj_y, proj_x] = points
        proj_intensity[proj_y, proj_x] = intensity
        proj_depth[proj_y, proj_x] = depth

        cloud = np.concatenate([proj_xyz,
                                proj_intensity.reshape((H, W, 1)),
                                proj_depth.reshape((H, W, 1))], axis=2)
        cloud = cloud.transpose((2, 0, 1))

        power = 16
        depth_img = np.copy(proj_depth)  # depth
        depth_img[depth_img > 0] = depth_img[depth_img > 0] ** (1 / power)
        depth_img[depth_img > 0] = (depth_img[depth_img > 0] - depth_img[depth_img > 0].min()) / \
                                   (depth_img[depth_img > 0].max() - depth_img[depth_img > 0].min())

        depth_msg = msgify(Image, depth_img, '32FC1')
        self.resized_depth_pub.publish(depth_msg)

        return cloud

    def model_inference(self, xyzir):
        # Apply inference preprocessing transforms
        batch = torch.from_numpy(xyzir).unsqueeze(0).to(self.device)
        with torch.no_grad():
            pred = self.model(batch)['out']
        rospy.loginfo('Segmented result shape: %s', pred.shape)
        return pred

    def postprocessing(self, pred, xyzir):
        assert isinstance(pred, torch.Tensor)
        assert isinstance(xyzir, np.ndarray)
        pred = pred.squeeze(0).cpu().numpy()
        labels = np.argmax(pred, axis=0)

        # labels_vis = cv2.resize(labels.astype('float'),
        #                         (labels.shape[1] // 2, labels.shape[0] // 2),
        #                         interpolation=cv2.INTER_LINEAR).astype('int8')
        # colors_vis = convert_color(labels_vis, color_map=self.color_map)
        # cv2.imshow('Predicted labels', colors_vis)
        # cv2.waitKey(1)

        colors = convert_color(labels, color_map=self.color_map)
        assert xyzir.shape[0] >= 3
        assert len(xyzir.shape) == 3  # 5 x H x W
        xyz = xyzir[:3, ...]
        rgb = colors.transpose((2, 0, 1)) / 255.  # 3 x H x W
        assert xyz.shape[1:] == rgb.shape[1:]
        xyzrgb = np.concatenate([xyz, rgb], axis=0)
        C, H, W = xyzrgb.shape
        n_pts = H * W
        xyzrgb = xyzrgb.reshape((C, -1)).T
        assert xyzrgb.shape == (n_pts, C)

        if self.label_map is not None:
            labels = self.label_map[labels]

        labels = labels.reshape((n_pts, 1))
        xyz_rgb_l = np.concatenate([xyzrgb, labels], axis=1)
        assert xyz_rgb_l.shape == (n_pts, C+1)

        rospy.logdebug('XYZ_RGB_L cloud shape: %s', xyzrgb.shape)
        return np.asarray(xyz_rgb_l, dtype=np.float32)

    def segment_cloud_cb(self, pc_msg):
        assert isinstance(pc_msg, PointCloud2)
        self.lidar_frame = pc_msg.header.frame_id

        # Discard old messages.
        msg_stamp = rospy.Time.now()
        age = (msg_stamp - pc_msg.header.stamp).to_sec()
        if age > self.max_age:
            rospy.logwarn('Discarding points %.1f s > %.1f s old.', age, self.max_age)
            return

        # Transform local map to ground truth localization frame
        cloud = numpify(pc_msg)
        cloud = structured_to_unstructured(cloud[self.input_pc_fields])
        rospy.logdebug('Point cloud of shape %s is received', cloud.shape)

        xyzir = self.preprocessing(cloud)
        pred = self.model_inference(xyzir)
        xyz_rgb_l = self.postprocessing(pred, xyzir=xyzir)

        # publish result
        stamp = rospy.Time.now()
        segm_pc_msg = msgify_cloud(xyz_rgb_l, frame=self.lidar_frame, stamp=stamp, names=self.output_pc_filelds)
        self.segm_cloud_pub.publish(segm_pc_msg)


if __name__ == '__main__':
    rospy.init_node('cloud_segmentation', log_level=rospy.DEBUG)
    proc = CloudProcessor(cloud_topic=rospy.get_param('~cloud_in', 'cloud_in'))
    rospy.spin()
