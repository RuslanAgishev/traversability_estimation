#!/usr/bin/env python

import numpy as np
from traversability_estimation.datasets import TraversabilityDataset
from traversability_estimation.segmentation import filter_grid, filter_range
from traversability_estimation.models.robot_terrain_interaction import RigidBodySoftTerrain
import os
from mayavi import mlab
from scipy.spatial.transform import Rotation
from torchdiffeq import odeint
import torch


def run(height_map):
    OUTPUT_PATH = '/home/ruslan/workspaces/traversability_ws/src/traversability_estimation/data/output'
    CREATE_MOVIE = 1
    torch.set_default_dtype(torch.float64)

    system_true = RigidBodySoftTerrain(height=height_map, damping=300.0, elasticity=5000.0, mass=20.0,
                                       init_pos_x=[6.5, 9.5, 1.])

    total_time = 4.0
    number_of_samples = 100
    t0, state = system_true.get_initial_state()
    tt = torch.linspace(float(t0), total_time, number_of_samples)
    x_traj = odeint(system_true.forward, state, tt, atol=1e-3, rtol=1e-3)

    H, W = height_map.shape

    pos_x, pos_R, vel_x, vel_omega, aux = x_traj
    x_grid, y_grid = np.mgrid[0:H, 0:W]
    points = system_true.d.detach().numpy()
    for t in range(pos_x.shape[0]):
        _, _, _, _, f = system_true.forward(tt[t], (pos_x[t], pos_R[t], vel_x[t], vel_omega[t], aux[t]))

        mlab.clf()
        mlab.plot3d(pos_x[0:(t + 1), 0].detach().numpy(), pos_x[0:(t + 1), 1].detach().numpy(),
                    pos_x[0:(t + 1), 2].detach().numpy(), color=(1, 1, 1), line_width=2.0)
        mlab.surf(x_grid, y_grid, height_map, opacity=0.5, representation='wireframe', line_width=5.0)
        mlab.surf(x_grid, y_grid, height_map, color=(0.5, 0.5, 1.0), opacity=0.5, representation='surface')
        cog = pos_x[t].detach().numpy()
        rot = pos_R[t].detach().numpy()
        d = rot @ points
        mlab.points3d(cog[0] + d[0, :], cog[1] + d[1, :], cog[2] + d[2, :], scale_factor=0.25)
        mlab.quiver3d(cog[0] + d[0, :], cog[1] + d[1, :], cog[2] + d[2, :], f[0].detach().numpy(),
                      f[1].detach().numpy(), f[2].detach().numpy(), scale_factor=0.005)
        # robot.plot_robot_Rt([], pos_R[t].detach().numpy(), pos_x[t].detach().numpy())
        mlab.view(azimuth=150 - t, elevation=60, distance=30.0)
        if CREATE_MOVIE:
            mlab.savefig(filename=OUTPUT_PATH + '{:04d}_frame'.format(t) + '.png', magnification=1.0)

    mlab.show()


def get_height_map(vis=True, grid_res=0.1, min_dist=0.1, max_dist=10.0, h_max=0.8):
    # Load traversability data
    # path = '/home/ruslan/data/bags/traversability/marv/ugv_2022-08-12-15-18-34_trav/'
    # path = '/home/ruslan/data/bags/traversability/marv/ugv_2022-08-12-16-37-03_trav/'
    path = '/home/ruslan/data/bags/traversability/marv/ugv_2022-08-12-15-30-22_trav/'
    assert os.path.exists(path)
    ds = TraversabilityDataset(path, cloud_topic='os_cloud_node/destaggered_points')
    print('Dataset contains %i samples' % len(ds))

    # Choose data sample
    # i = np.random.choice(range(len(ds)))
    i = 3
    sample = ds[i]
    depth, label, points = sample
    traj = ds.get_traj(i)

    # visualize a sample from the data set
    # _ = ds.__getitem__(i, visualize=True)

    print('%i-th sample contains range image of shape: %s, its label of shape: %s, point cloud of shape: %s, '
          'and traversed trajectory of shape: %s' %
          (i, depth.shape, label.shape, points.shape, traj.shape))

    # Filter point cloud and its label
    points_filtered = points.copy()

    _, mask = filter_range(points, min_dist, max_dist, return_mask=True)
    points_filtered = points_filtered[mask]

    _, mask = filter_grid(points_filtered, grid_res, return_mask=True)
    points_filtered = points_filtered[mask]

    # # transform points to align with the ground (calibration issue)
    # R = Rotation.from_euler('y', 2, degrees=True).as_matrix()
    # points_filtered = points_filtered @ R.T

    # remove points which are above the robot
    mask = points_filtered[:, 2] <= h_max
    points_filtered_hm = points_filtered[mask]

    # Create height map and add labels to traversed cells
    H = W = round(2 * max_dist / grid_res)
    height_map = np.full((H, W), 0.0)
    print('Height map shape:', height_map.shape)
    ids = (points_filtered_hm[:, :2] - points_filtered_hm[:, :2].min(axis=0)) // grid_res
    ids = np.asarray(ids, dtype=int)
    for i, (idx, idy) in enumerate(ids):
        height_map[idx, idy] = points_filtered_hm[i, 2]

    if vis:
        # visualization: height map, point cloud, trajectory
        x_grid, y_grid = np.mgrid[-H//2:H//2, -W//2:W//2] * grid_res
        mlab.plot3d(traj[:, 0, 3], traj[:, 1, 3], traj[:, 2, 3], color=(0, 0, 1), line_width=4.0)
        # mlab.points3d(points_filtered[:, 0], points_filtered[:, 1], points_filtered[:, 2],
        #               scale_factor=0.1, colormap="copper")
        mlab.points3d(points_filtered_hm[:, 0], points_filtered_hm[:, 1], points_filtered_hm[:, 2],
                      scale_factor=0.1, colormap="copper")
        mlab.surf(x_grid, y_grid, height_map, opacity=0.5, representation='wireframe', line_width=2.0)
        mlab.surf(x_grid, y_grid, height_map, color=(0.5, 0.5, 1.0), opacity=0.5, representation='surface')
        mlab.show()

    return height_map, traj


def main():
    height_map, traj = get_height_map(vis=False)
    run(height_map)


if __name__ == '__main__':
    main()
