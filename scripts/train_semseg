#!/usr/bin/env python

from traversability_estimation.rellis_3d import DatasetSemSeg as Dataset
from torch.utils.data import DataLoader
import torch
import segmentation_models_pytorch as smp


IMG_SIZE = (352, 640)  # src_size // 4
# size = (704, 1280)  # src_size // 2
BATCH_SIZE = 5
n_epochs = 100
LR = 1e-4
# Create model and train
ENCODER = 'mobilenet_v2'
ENCODER_WEIGHTS = 'imagenet'
CLASSES = ['void', 'dirt', 'grass', 'tree', 'pole', 'water',
           'sky', 'vehicle', 'object', 'asphalt', 'building',
           'log', 'person', 'fence', 'bush', 'concrete',
           'barrier', 'puddle', 'mud', 'rubble']
# could be None for logits or 'softmax2d' for multiclass segmentation
ACTIVATION = 'sigmoid' if len(CLASSES) == 1 else 'softmax2d'
DEVICE = 'cuda'

# create segmentation model with pretrained encoder
model = smp.Linknet(
    encoder_name=ENCODER,
    encoder_weights=ENCODER_WEIGHTS,
    in_channels=3,
    classes=len(CLASSES),
    activation=ACTIVATION,
)
# model = torch.load('../config/weights/smp/mobilenet_v2_352x640_lr1e-4_iou_0.46.pth')
model = model.train()

train_dataset = Dataset(classes=CLASSES, crop_size=IMG_SIZE, split='train')
valid_dataset = Dataset(classes=CLASSES, crop_size=IMG_SIZE, split='val')

train_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True, num_workers=12)
valid_loader = DataLoader(valid_dataset, batch_size=1, shuffle=False, num_workers=4)

# Dice/F1 score - https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient
loss = smp.utils.losses.DiceLoss()
# IoU/Jaccard score - https://en.wikipedia.org/wiki/Jaccard_index
metrics = [
    smp.utils.metrics.IoU(threshold=0.5),
]

optimizer = torch.optim.Adam([ 
    dict(params=model.parameters(), lr=LR),
])

# create epoch runners 
# it is a simple loop of iterating over dataloader`s samples
train_epoch = smp.utils.train.TrainEpoch(
    model, 
    loss=loss, 
    metrics=metrics, 
    optimizer=optimizer,
    device=DEVICE,
    verbose=True,
)

valid_epoch = smp.utils.train.ValidEpoch(
    model, 
    loss=loss, 
    metrics=metrics, 
    device=DEVICE,
    verbose=True,
)

# train model
max_score = 0
for i in range(0, n_epochs):
    print('\nEpoch: {}'.format(i))
    train_logs = train_epoch.run(train_loader)
    valid_logs = valid_epoch.run(valid_loader)
    
    # do something (save model, change lr, etc.)
    if max_score < valid_logs['iou_score']:
        max_score = valid_logs['iou_score']
        torch.save(model, './%s_%dx%d_lr%g_iou_%.2f.pth' % (ENCODER, IMG_SIZE[0], IMG_SIZE[1], LR, max_score))
        print('Model saved!')
        
    if i == 25:
        optimizer.param_groups[0]['lr'] = LR / 10.0
        print('Decrease decoder learning rate!')
