#!/usr/bin/env python

import os
import cv2
from datasets.laserscan import SemLaserScan
from datasets.base_dataset import TRAVERSABILITY_COLOR_MAP, TRAVERSABILITY_LABELS, VOID_VALUE
from datasets.base_dataset import FLEXIBILITY_COLOR_MAP, FLEXIBILITY_LABELS
from traversability_estimation.utils import get_label_map, convert_label, visualize_cloud, visualize_imgs
import rospy
from sensor_msgs.msg import Image, PointCloud2
from ros_numpy import msgify, numpify
import numpy as np
from numpy.lib.recfunctions import structured_to_unstructured, unstructured_to_structured
import torch
import yaml
from threading import RLock


pkg_path = os.path.realpath(os.path.join(os.path.dirname(__file__), '..'))


def msgify_cloud(cloud, frame, stamp, names):
    assert cloud.ndim == 2
    cloud = unstructured_to_structured(cloud, names=names)
    msg = msgify(PointCloud2, cloud)
    msg.header.frame_id = frame
    msg.header.stamp = stamp
    return msg


# transformation between Cartesian coordinates and polar coordinates
def cart2polar(input_xyz):
    rho = np.sqrt(input_xyz[:, 0] ** 2 + input_xyz[:, 1] ** 2)
    phi = np.arctan2(input_xyz[:, 1], input_xyz[:, 0])
    return np.stack((rho, phi, input_xyz[:, 2]), axis=1)


def polar2cat(input_xyz_polar):
    # print(input_xyz_polar.shape)
    x = input_xyz_polar[0] * np.cos(input_xyz_polar[1])
    y = input_xyz_polar[0] * np.sin(input_xyz_polar[1])
    return np.stack((x, y, input_xyz_polar[2]), axis=0)


class CloudSegmentor:
    def __init__(self, cloud_topic='cloud'):
        self.lidar_frame = None

        self.lock = RLock()
        self.device = rospy.get_param('~device', 'cpu')

        self.model_weights = rospy.get_param('~weights', "student_kitti_traversablity_f0_0_time_ema.pt")
        self.model_path = os.path.join(pkg_path, "config/weights/", "t-concord3d/%s" % self.model_weights)
        assert os.path.exists(self.model_path)

        # self.model = self.load_model()
        # rospy.loginfo('Loaded cloud segmentation model: %s', self.model_weights)

        self.input_pc_fields = ['x', 'y', 'z']
        self.output_pc_fields = ['x', 'y', 'z', 'r', 'g', 'b', 'cost']

        self.debug = rospy.get_param('~debug', False)

        # point cloud which time stamp is older is not being processed
        self.max_age = rospy.get_param('~max_age', 0.5)

        self.grid_size = np.array([480, 360,  32])

        self.segm_cloud_pub = rospy.Publisher(rospy.get_param('~cloud_out', '~points'), PointCloud2, queue_size=1)
        self.depth_pub = rospy.Publisher('~depth', Image, queue_size=1)

        self.cloud_sub = rospy.Subscriber(cloud_topic, PointCloud2, self.segment_cloud_cb)
        rospy.loginfo('Point cloud segmentation node is ready.')

    def load_model(self):
        model = torch.load(self.model_path, map_location=self.device)
        model = model.eval()
        return model

    def preprocessing(self, cloud):
        pass

    def model_inference(self, depth):
        pass

    def postprocessing(self, label_pred, xyz):
        pass

    def segment_cloud_cb(self, pc_msg):
        assert isinstance(pc_msg, PointCloud2)
        self.lidar_frame = pc_msg.header.frame_id

        # Discard old messages.
        msg_stamp = rospy.Time.now()
        age = (msg_stamp - pc_msg.header.stamp).to_sec()
        if age > self.max_age:
            rospy.logwarn('Cloud segmentation: Discarding points %.1f s > %.1f s old.', age, self.max_age)
            return

        t0 = rospy.Time.now().to_sec()

        with self.lock:
            cloud = numpify(pc_msg)
            xyz = structured_to_unstructured(cloud[self.input_pc_fields])
            rospy.logdebug('Point cloud of shape %s is received', xyz.shape)

            xyz = xyz.reshape((-1, 3))
            xyz_pol = cart2polar(xyz)

            max_bound_r = np.percentile(xyz_pol[:, 0], 100, axis=0)
            min_bound_r = np.percentile(xyz_pol[:, 0], 0, axis=0)
            max_bound = np.max(xyz_pol[:, 1:], axis=0)
            min_bound = np.min(xyz_pol[:, 1:], axis=0)
            max_bound = np.concatenate(([max_bound_r], max_bound))
            min_bound = np.concatenate(([min_bound_r], min_bound))

            # get grid index
            crop_range = max_bound - min_bound
            cur_grid_size = self.grid_size
            intervals = crop_range / (cur_grid_size - 1)

            if (intervals == 0).any(): print("Zero interval!")
            grid_ind = (np.floor((np.clip(xyz_pol, min_bound, max_bound) - min_bound) / intervals)).astype(int)

            # voxel_position = np.zeros(self.grid_size, dtype=np.float32)
            # dim_array = np.ones(len(self.grid_size) + 1, int)
            # dim_array[0] = -1
            # voxel_position = np.indices(self.grid_size) * intervals.reshape(dim_array) + min_bound.reshape(dim_array)
            # voxel_position = polar2cat(voxel_position)

            # center data on each voxel for PTnet
            voxel_centers = (grid_ind.astype(np.float32) + 0.5) * intervals + min_bound
            return_xyz = xyz_pol - voxel_centers
            return_xyz = np.concatenate((return_xyz, xyz_pol, xyz[:, :2]), axis=1)

            sig = np.zeros((len(return_xyz), 1))
            return_fea = np.concatenate((return_xyz, sig), axis=1)

            return_fea = torch.from_numpy(return_fea).to(self.device)
            xyz = torch.from_numpy(xyz).to(self.device)
            print(return_fea.shape, xyz.shape)

            # predict_labels_raw = self.model([return_fea], [xyz], batch_size=1)
            # print(predict_labels_raw.shape)


def main():
    rospy.init_node('cloud_segmentation_t_concord3d', log_level=rospy.DEBUG)
    proc = CloudSegmentor(cloud_topic=rospy.get_param('~cloud_in', 'points'))
    rospy.spin()


if __name__ == '__main__':
    main()
