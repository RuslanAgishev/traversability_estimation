#!/usr/bin/env python
"""Generate self-supervised data from ROS bag files with robot trajectories.

Paramaters:
- Simplified robot model from primitives (bounding boxes, spheres).
- Lookahead time / distance to mark traversed-through points.

Multi-pass processing:
1. Load transforms from bag files into a buffer. There have to be a transform
   from the fixed frame to the robot.
2. Process bags again and annotate points within given horizon contained in
   the model primitives.
"""
from __future__ import absolute_import, division, print_function
from argparse import ArgumentParser
from glob import glob
from matplotlib import cm
import numpy as np
from numpy.lib.recfunctions import merge_arrays, structured_to_unstructured, unstructured_to_structured
import os
from ros_numpy import msgify, numpify
from rosbag import Bag, ROSBagException, Compression
import rospy
from sensor_msgs.msg import PointCloud2
from tf2_ros import BufferCore, TransformException
from traversability_estimation.segmentation import fit_cylinders, fit_planes, fit_sticks
from traversability_estimation.utils import show_cloud
from tqdm import tqdm
import yaml

LABEL_FIELD_NAME = 'flexible'
LABEL_RIGID = 0
LABEL_FLEXIBLE = 1
IGNORE_LABEL = 255


def parse_args():
    parser = ArgumentParser(epilog="""Path format uses following placeholders:
    {dir} - parent directory of the first bag file,
    {name} - name without extension of the first bag file,
    {topic} - name of the topic as read from bag file,
    {secs}, {nsecs} - timestamp from the header (if available).
    """)
    parser.add_argument('--topics', type=str, nargs='+')
    parser.add_argument('--fixed-frame', type=str, default='map')
    parser.add_argument('--robot-frame', type=str, default='base_link')
    # parser.add_argument('--discard-radius', type=float, default=None, help='Discard points within this radius.')
    # parser.add_argument('--discard-box', type=yaml.safe_load, default=None, help='Discard points within this box.')
    parser.add_argument('--discard-empty', type=bool, default=True)
    parser.add_argument('--input-step', type=int, default=1)
    parser.add_argument('--input-start', type=float, default=-float('inf'), help='Start time in seconds.')
    parser.add_argument('--input-end', type=float, default=float('inf'), help='End time in seconds.')
    # parser.add_argument('--radius', '-r', type=float, default=None, help='Robot radius for the segmentation.')
    # parser.add_argument('--box', '-b', type=yaml.safe_load, default=None, help='Bounding box for flexible points.')
    parser.add_argument('--discard-model', type=str, default=None, help='Model at current position discarding points.')
    parser.add_argument('--flexible-model', type=str, default=None, help='Model to move along robot path marking points flexible.')
    parser.add_argument('--rigid-model', type=str, default=None, help='Model to move along robot path marking points rigid.')
    parser.add_argument('--distance-horizon', '-d', type=float, default=10.0)
    parser.add_argument('--time-horizon', '-t', type=float, nargs='+', default=[10.0])
    parser.add_argument('--time-step', '-s', type=float, default=0.5)
    # parser.add_argument('--time-horizon-direction', type=str, default='future', help='Check poses from history, future, or both.')
    # FIXME: Handle redundant /?
    parser.add_argument('--output-path', '-o', type=str, default='{dir}/{name}/{topic}/{secs}_{nsecs:09d}.npz')
    # parser.add_argument('--cloud-path', '-c', type=str, default='{dir}/{name}/{topic}/{secs}_{nsecs:09d}.npz')
    # parser.add_argument('--image-path', '-i', type=str, default='{dir}/{name}/{topic}/{secs}_{nsecs:09d}.npz')
    parser.add_argument('--output-bag-path', '-O', type=str, default='{dir}/{name}_segmented.bag')
    parser.add_argument('--output-topic', type=str, default='{topic}_segmented')
    parser.add_argument('--output-period', type=float, default=None)
    parser.add_argument('bag_paths', type=str, nargs='+')
    args = parser.parse_args()
    print(args)
    return args


def affine(tf, x):
    assert tf.ndim == 2
    assert x.ndim == 2
    assert tf.shape[1] == x.shape[0] + 1
    y = np.matmul(tf[:-1, :-1], x) + tf[:-1, -1:]
    return y


class Body(object):
    def __init__(self, pose=None):
        if pose is None:
            pose = np.eye(4)
        self.pose = pose
        self.pose_inv = np.linalg.inv(pose)

    def contains_local(self, x):
        # return np.zeros((x.shape[1],), dtype=bool)
        raise NotImplementedError()

    def contains(self, x):
        return self.contains_local(affine(self.pose_inv, x))


class Sphere(Body):
    def __init__(self, origin=(0, 0, 0), radius=1.0):
        origin = np.asarray(origin).reshape((3, -1))
        pose = np.eye(4)
        pose[:3, 3:] = -origin
        super(Sphere, self).__init__(pose=pose)
        self.origin = origin
        self.radius = radius

    def contains_local(self, x):
        c = np.linalg.norm(x, axis=0) < self.radius
        return c

    def __str__(self):
        return ('Sphere(origin=(%.3f, %.3f, %.3f), radius=%.3f)'
                % (tuple(self.origin.ravel()) + (self.radius,)))


class Box(Body):
    def __init__(self, extents=((-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0))):
        extents = np.asarray(extents)
        assert extents.shape == (3, 2)
        super(Box, self).__init__()
        self.extents = extents

    def contains_local(self, x):
        c = np.logical_and(self.extents[:, :1] <= x, x <= self.extents[:, 1:]).all(axis=0)
        return c

    def __str__(self):
        return ('Box(extents=((%.3f, %.3f), (%.3f, %.3f), (%.3f, %.3f)))'
                % tuple(self.extents.ravel()))


class Bodies(Body):
    def __init__(self, bodies, pose=None):
        super(Bodies, self).__init__(pose=pose)
        self.bodies = bodies

    def contains_local(self, x):
        c = np.zeros((x.shape[1],), dtype=bool)
        for body in self.bodies:
            c = np.logical_or(c, body.contains_local(x))
        return c

    def __str__(self):
        return 'Bodies(%s)' % ', '.join(str(b) for b in self.bodies)


def slots(msg):
    """Return message attributes (slots) as list."""
    return [getattr(msg, var) for var in msg.__slots__]


def get_topic_types(bag):
    return {k: v.msg_type for k, v in bag.get_type_and_topic_info().topics.items()}


def load_buffer(bag_paths):
    tf_topics = ['/tf', '/tf_static']
    # buffer = BufferCore(cache_time=rospy.Duration(2**31 - 1))
    # buffer = BufferCore(cache_time=rospy.Duration(24 * 60 * 60))
    buffer = BufferCore(rospy.Duration(24 * 60 * 60))
    for path in bag_paths:
        try:
            with Bag(path, 'r') as bag:
                for topic, msg, stamp in tqdm(bag.read_messages(topics=tf_topics),
                                              desc='%s: reading transforms' % path.split('/')[-1],
                                              total=bag.get_message_count(topic_filters=tf_topics)):
                    if topic == '/tf':
                        for tf in msg.transforms:
                            buffer.set_transform(tf, 'bag')
                    elif topic == '/tf_static':
                        for tf in msg.transforms:
                            buffer.set_transform_static(tf, 'bag')
        except ROSBagException as ex:
            print('Could not read %s: %s' % (path, ex))

    return buffer


def fit_primitives(x_valid):
    # Fit obstacle models (trunks or branches as cylinders, ground or walls as plane).
    models = []
    # models = fit_cylinders(segmented, 0.05, [0.05, 0.25])
    # models = fit_cylinders(segmented, 0.05, max_iterations=1000, visualize=True, min_support=20, max_models=5)
    # models = fit_sticks(segmented, 0.25, max_iterations=10000, visualize=True, min_support=20, cluster_eps=0.1)
    # models += fit_planes(segmented, 0.1, max_iterations=10000, visualize=True, min_support=20, cluster_eps=0.1)
    # models += fit_planes(segmented, 0.05, max_iterations=1000, min_support=20, max_models=20, cluster_eps=0.2,
    #                      visualize=True)
    # models += fit_planes(x_valid.T, 0.05, max_iterations=1000, min_support=100, max_models=40, cluster_eps=0.2,
    #                      verbose=1, visualize=True)
    models += fit_planes(x_valid.T, 0.05, max_iterations=100, min_support=25, max_models=10, cluster_eps=0.25,
                         verbose=1, visualize=True)
    # models += fit_cylinders(x_valid.T, 0.05, radius_limits=[0.05, 0.5], max_iterations=100, min_support=100,
    #                         max_models=10, cluster_eps=0.2, verbose=1, visualize=True)
    return models


def segment_cloud(flexible_model, arr, tfs, rigid_model=None, discard_tf=None, discard_model=None):
    assert flexible_model is None or isinstance(flexible_model, Body)
    assert isinstance(arr, np.ndarray)
    assert rigid_model is None or isinstance(rigid_model, Body)
    assert discard_model is None or isinstance(discard_model, Body)

    x = structured_to_unstructured(arr.ravel()[['x', 'y', 'z']])
    x = x.T

    # Initialize all labels as unknown.
    # 0: occupied, 1: empty, IGNORE_LABEL: label unknown.
    labels = np.full((x.shape[1],), IGNORE_LABEL, dtype=np.uint8)

    # Identify valid points, i.e., points with valid depth which are not part
    # of the robot (contained by the discard model).
    valid = (x != 0.0).any(axis=0)
    valid = np.logical_and(valid, np.isfinite(x).all(axis=0))
    if discard_model:
        assert discard_tf is not None
        y = affine(discard_tf, x)
        valid = np.logical_and(valid, ~discard_model.contains(y))
    valid_ind = np.flatnonzero(valid)

    # Mark valid points which are contained by future model poses as empty.
    x_valid = x[:, valid]
    flexible_valid = np.zeros((x_valid.shape[1],), dtype=bool)
    rigid_valid = np.zeros((x_valid.shape[1],), dtype=bool)
    for tf in tfs:
        assert isinstance(tf, np.ndarray)
        y_valid = affine(tf, x_valid)
        if flexible_model:
            flexible_valid = np.logical_or(flexible_valid, flexible_model.contains(y_valid))
        if rigid_model:
            rigid_valid = np.logical_or(rigid_valid, rigid_model.contains(y_valid))

    # Fit geometric primitives to points and mark their inliers as rigid.
    primitives = fit_primitives(x_valid)
    for primitive, indices in primitives:
        labels[valid_ind[indices]] = LABEL_RIGID
    show_cloud(x.T, labels, min=0, max=2, colormap=cm.jet)

    flexible = np.zeros((x.shape[1],), dtype=bool)
    flexible[valid] = flexible_valid
    rigid = np.zeros((x.shape[1],), dtype=bool)
    rigid[valid] = rigid_valid
    labels[valid & rigid] = LABEL_RIGID
    # Flexible overrides rigid label (if robot went through it cannot be rigid).
    labels[valid & flexible] = LABEL_FLEXIBLE
    show_cloud(x.T, labels, min=0, max=2, colormap=cm.jet)

    labels = labels.reshape((-1, 1))
    labels = unstructured_to_structured(labels, names=[LABEL_FIELD_NAME])
    labels = labels.reshape(arr.shape)
    segmented = merge_arrays((arr, labels), flatten=True)

    return segmented


def generate_data(bag_paths=None, topics=None, fixed_frame=None, robot_frame=None, flexible_model=None, rigid_model=None,
                  discard_model=None, discard_empty=False, input_step=1, input_start=0.0, input_end=float('inf'),
                  distance_horizon=None, time_horizon=None, time_step=None,
                  output_path=None, output_bag_path=None, output_topic=None, output_period=None):
    assert bag_paths, bag_paths

    if len(time_horizon) == 1:
        time_horizon = [0.0] + time_horizon
    assert len(time_horizon) == 2, time_horizon
    assert time_horizon[0] < time_horizon[1], time_horizon
    print('Time horizon:', time_horizon)

    dir = os.path.dirname(bag_paths[0])
    name, _ = os.path.splitext(os.path.basename(bag_paths[0]))

    # n = int(np.floor(time_horizon / time_step))
    n = [int(np.floor(h / time_step)) for h in time_horizon]

    last_out = {}

    if output_bag_path:
        output_bag_path = output_bag_path.format(dir=dir, name=name)
        if output_bag_path in bag_paths:
            print('Output %s removed from input bag files.' % output_bag_path)
            del bag_paths[bag_paths.index(output_bag_path)]
        # else:
        #     print('%s not in %s.' % (output_bag_path, bag_paths))
        output_bag = Bag(output_bag_path, 'w', compression=Compression.LZ4)
    else:
        output_bag = None

    buffer = load_buffer(bag_paths)
    for bag_path in bag_paths:

        with Bag(bag_path, 'r') as bag:

            topic_types = get_topic_types(bag)
            # print('Topic types:', *['%s: %s' % (k, v)
            #                         for k, v in topic_types.items() if k in topics], sep='\n')
            i = -1
            for topic, msg, stamp in tqdm(bag.read_messages(topics=topics),
                                          desc='%s: generating data' % bag_path.split('/')[-1],
                                          total=bag.get_message_count(topic_filters=topics)):
                i += 1
                if i % input_step != 0:
                    continue
                if stamp.to_sec() < input_start or stamp.to_sec() > input_end:
                    print('Skipping %s at %.3f s.' % (topic, stamp.to_sec()))
                    continue

                fmt_kwargs = {'dir': dir, 'name': name, 'topic': topic}
                if hasattr(msg, 'header'):
                    secs, nsecs = msg.header.stamp.secs, msg.header.stamp.nsecs
                    start = msg.header.stamp.to_sec()
                else:
                    secs, nsecs = stamp.secs, stamp.nsecs
                    start = stamp.to_sec()
                fmt_kwargs['secs'], fmt_kwargs['nsecs'] = secs, nsecs

                if output_period and topic in last_out and start - last_out[topic] < output_period:
                    continue

                # TODO: Always look up t=0.
                tfs = []
                for t in np.linspace(start - n[0] * time_step, start + n[1] * time_step, sum(n) + 1):
                    try:
                        tf = buffer.lookup_transform_full_core(robot_frame, rospy.Time.from_seconds(t),
                                                               msg.header.frame_id, msg.header.stamp,
                                                               fixed_frame)
                    except TransformException as ex:
                        # print('Could not transform from %s to %s at %.3f s.' % (msg.header.frame_id, robot_frame, t))
                        continue
                    tf = numpify(tf.transform)
                    if tfs:
                        # Check distance horizon.
                        diff = np.matmul(tfs[n[0]], np.linalg.inv(tf))
                        distance = np.linalg.norm(diff[:-1, -1])
                        if distance > distance_horizon:
                            print('Distance horizon reached, %.3f m > %.3f m.' % (distance, distance_horizon))
                            break
                    tfs.append(tf)

                # print('%i poses gathered for %s at %.3f s.' % (len(tfs), topic, stamp.to_sec()))
                if not tfs:
                    continue

                if topic_types[topic] == 'sensor_msgs/PointCloud2':
                    msg = PointCloud2(*slots(msg))
                    arr = numpify(msg)
                    segmented_arr = segment_cloud(flexible_model, arr, tfs, rigid_model=rigid_model,
                                                  discard_tf=tfs[n[0]], discard_model=discard_model)

                    n_valid_labels = (segmented_arr[LABEL_FIELD_NAME] != IGNORE_LABEL).sum()
                    if discard_empty and n_valid_labels == 0:
                        print('Discarding cloud with no valid labels.')
                        continue
                    else:
                        print('Storing cloud with %i valid labels.' % n_valid_labels)

                    last_out[topic] = start

                    if output_path is not None:
                        p = output_path.format(**fmt_kwargs)
                        os.makedirs(os.path.dirname(p), exist_ok=True)
                        np.savez_compressed(p, {'cloud': segmented_arr})

                    if output_bag is not None:
                        t = output_topic.format(topic=topic)
                        segmented_msg = msgify(PointCloud2, segmented_arr)
                        segmented_msg.header = msg.header
                        output_bag.write(t, segmented_msg, stamp)
    if output_bag:
        output_bag.close()


def main():
    args = parse_args()
    # print(vars(args))
    # if args.box:
    #     args.box = yaml.safe_load(args.box)
    # if args.discard_box:
    #     args.discard_box = yaml.safe_load(args.discard_box)

    print('Collecting bag files...')
    print('Bags:', *args.bag_paths, sep='\n')
    args.bag_paths = sum((glob(b) for b in args.bag_paths), start=[])
    print('Found %i bag files.' % len(args.bag_paths))
    print('Bags:', *args.bag_paths, sep='\n')

    if args.discard_model:
        args.discard_model = eval(args.discard_model)
        print('Discard model:', args.discard_model)
    if args.flexible_model:
        # assert args.radius is None
        # assert args.box is None
        args.flexible_model = eval(args.flexible_model)
        print('Flexible model:', args.flexible_model)
    # else:
    #     bodies = []
    #     if args.radius:
    #         body = Sphere(radius=args.radius)
    #         bodies.append(body)
    #     if args.box:
    #         body = Box(extents=args.box)
    #         bodies.append(body)
    #     model = Bodies(bodies)

    if args.rigid_model:
        args.rigid_model = eval(args.rigid_model)
        print('Rigid model:', args.rigid_model)

    bodies = []
    # if args.discard_radius:
    #     body = Sphere(radius=args.discard_radius)
    #     bodies.append(body)
    # if args.discard_box:
    #     body = Box(extents=args.discard_box)
    #     bodies.append(body)
    discard_model = Bodies(bodies) if bodies else None
    print('Discard model:', discard_model)

    # generate_data(args.bags, args.topics, args.fixed_frame, args.robot_frame,
    #               model=args.flexible_model, rigid_model=rigid_model,
    #               discard_model=discard_model, discard_empty=args.discard_empty,
    #               input_step=args.input_step, input_start=args.input_start, input_end=args.input_end,
    #               distance_horizon=args.distance_horizon, time_horizon=args.time_horizon, time_step=args.time_step,
    #               output_path_fmt=args.output_path, output_bag_path_fmt=args.output_bag_path,
    #               output_topic_fmt=args.output_topic, output_period=args.output_period)
    generate_data(**vars(args))


if __name__ == '__main__':
    main()
